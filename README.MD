# Атака с нулевым кликом или как старый софт может вставить палки в колёса современному приложению

## Предыстория

### Важные обновления системы безопасности

Несмотря на то, что я являюсь активным пользователем техники Apple, я редко обращаю внимание на подробности обновлений, выпущенных яблочной корпорацией. Как бы там ни было, недавно я начал обращать внимание на названия обновлений и обнаружил следующее: летом 2023 года компания выпустила особые обновления безопасности, что меня крайне заинтересовало. Недолго думая, я начал изучать вопрос и узнал о таком интересном явлении, как атака с нулевым кликом. Что удивительно, эксплойту этого типа порядка 2 лет, а он всё никак не даёт покоя разработчикам. О нем я и расскажу далее. 

## Описание инцидента

### NSO Group. Pegasus.

После расследования в июле 2021 года в СМИ появилась информация о том, что шпионское ПО Pegasus используется авторитарными режимами для взлома телефонов (под iOS и Android) и слежки за правозащитниками, оппозиционными журналистами и юристами. Особенность была в том, что пользователь совершенно никак не мог узнать о взломе. Для заражения устройства достаточно было знать номер телефона жертвы. Таким образом, среди пострадавших были отмечены порядка 50 тысяч телефонных номеров, зарегистрированных в следующих странах:
- Азербайджан
- Бахрейн
- Венгрия
- Индия
- Казахстан
- Марокко
- Мексика
- Объединённые Арабские Эмираты
- Руанда
- Саудовская Аравия

С тех пор корпорация Apple стала усердно выпускать обновления безопасности для защиты от одного из самых технически сложных эксплойтов.

## Описание и объяснение причин, приведших к инциденту (какие решения были приняты и почему, какие обстоятельства сложились неблагоприятным образом)

### Атака с нулевым кликом

Атака с нулевым кликом - это вид уязвимостей, позволяющих злоумышленнику выполнять вредоносные действия без взаимодействия с пользователем. Такие атаки позволяют киберпреступнику получить контроль над приложением или устройством без применения социальной инженерии.

Для точного определения конкретизируем уязвимость согласно тому, как она была обнажена в iOS. 

### iMessage

Эксплойт осуществлялся с помощью приложения iMessage (нативное приложение продукции Apple). Для установления слежки за устройством достаточно было отправить особое графическое изображение растрового формата (`.gif`) на номер телефона (или AppleID) жертвы. Неблагоприятным обстоятельством оказалось то, что разработчики захотели зациклить проигрывание гифок, а обработку скрыть от пользователя (то есть обработка `.gif` начиналась до того, как пользователь увидит уведомление о сообщении).

В общем и целом, это и есть причина, по которой данный эксплойт можно назвать "атака с нулевым кликом", ведь о его активации пользователь не знает ничего от слова совсем. Зафиксировать наличие "шпиона" на устройстве можно исключительно с помощью специалиста.

### ImageIO, CoreGraphics Framework и Xpdf toolkit

Для обработки `.gif` изображений код фреймворка ImageIO **автоматически определял формат переданного файла** (расширение файла игнорировалось). В качестве декодера выступало API фреймворка для рисования в iOS -- CoreGraphics PDF. Для парсинга же применялся доменный кодек изображений `JBIG2` (подробнее о процессе сжатия в следующей части доклада), чья реализация была взята из набора инструментов с **открытым исходным кодом** [Xpdf](https://www.xpdfreader.com/).

Использование кода парсера из легаси опенсорс набора инструментов нельзя назвать грубой ошибкой или ленью, поскольку данный код был написан во времена серьезных требований к памяти (конец 1990-х), а значит крайне хорошо сжимал изображения.

В совокупности автоопределение формата файла и уязвимый код парсера CodeGraphics `JBIG2` позволили в качестве файла передать поддельный `.gif` (содержащий в себе особый `.pdf`), который для побега из "песочницы" посредством сложных манипуляций переполнял буфер растрового изображения, эмулировал архитектуру компьютера и определял собственные сценарии.

## Описание технических деталей (побольше визуализации <u>систем</u>)

### ImageIO

Обратимся к коду библиотеки, где после расшифровки бинарных данных происходит создание объекта изображения:

```
NSData* payload = [handler decryptData:encryptedDataFromSender, ...];
if (isImagePayload) {
    UIImage* img = [UIImage imageWithData:payload];                                         //  вызов конструктора
    ...;
}
```

После которого выполняется следующий код (нужен для создания миниатюры [`thumbnail`] изображения в уведомлении):

```
CGImageRef cgImage = [image CGImage];                                                       //  стрктура растрового изображения или его маски
CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();                                 //  интерпретация цвета для изображения
CGContextRef cgContext = CGBitmapContextCreate(0, thumbnailWidth, thumbnailHeight, ...);    //  структура среды для отрисовки
CGContextDrawImage(cgContext, cgImage, ...);                                                //  отрисовка изображения
CGImageRef outImage = CGBitmapContextCreateImage(cgContext);                                //  стрктура растрового изображения или его маски
UIImage* thumbnail = [UIImage imageWithCGImage:outImage];
```

Автоопределение формата файла происходит в полиморфном вызове `testHeader` у наследников `IIO_Reader`:

```
bool IIO_Reader_LibJPEG::testHeader(IIO_Reader_LibJPEG *this, const unsigned __int8 *a2, unsigned __int64 a3, const __CFString *a4)
{
  return *a2 == 0xFF && a2[1] == 0xD8 && a2[2] == 0xFF;
}
```
Помимо IIO_Reader_LibJPEG (формат .jpeg), поддерживаются и следующие:

- IIO_Reader_**BMP**::testHeader
- IIO_Reader_**GIF**::testHeader
- IIO_Reader_**PDF**::testHeader
- IIO_Reader_**PNG**::testHeader
- ...

В совокупности описанные вызовы и определяют уязвимость нулевого клика.

### JBIG2 и методы сжатия

**JBIG2** [Joint Bi-level Image Experts Group 2] - это доменный кодек изображений (далее -- поток `JBIG2`) для бинарных изображений, работа которого основана на природе визуальной интерпретации человека (необязательно отрисовывать все пикселы, чтобы человек распознал символ).
- **доменный**: предназначен для работы с изображениями и обладает функциональностью, которая наиболее эффективна и оптимизирована для обработки этой конкретной области.
- **кодек изображений** (видеокодек): программа или алгоритм сжатия видеоданных и восстановления сжатых данных.
- **бинарное изображение**: каждый пиксел представляет один из двух цветов

Среди методов сжатия потока `JBIG2` можно отметить следующие:
- **сегментация и подстановка**: разделение изображения на различные сегменты и замена повторяющихся участков сегментами-шаблонами
- **уточняющее кодирование**: позволяет дополнительно сжимать изображения, добавляя детали к уже существующим сегментам, контролируя тем самым "потери" сжатия
- **бинаризация**: преобразует изображение в двоичный формат, разделяя его на фоновую и переднюю плоскости
- **адаптивное кодирование**: используется для кодирования двоичных данных с использованием переменной длины кодов
- **контекстное моделирование**: используется для предсказания вероятности появления определенных символов и оптимизации кодирования
- **арифметическое кодирование**: используется для эффективного представления символов с использованием дробных чисел

Первые два метода позволяют достичь экстремальных степеней сжатия. Они-то и имеют отношение к нашему эксплойту. Рассмотрим их получше.

### JBIG2: Сегментация и подстановка

```text


                                                                                                           ▄▄         ▄▄                                                        
  ▄▄█▀▀▀█▄█                                                ██                                             ███         ██   ██                   ██                              
▄██▀     ▀█                                                ██                                              ██              ██                   ██                              
██▀       ▀ ▄██▀██▄▀████████▄█████▄ ▀████████▄▀███  ▀███ ██████  ▄▄█ ██▀███▄███     ▄█▀██▄ ▀███▄███ ▄██▀██ ███████▄ ▀███ ██████  ▄ █▀█  ▄██▀████████▀███  ▀███ ▀███▄███ ▄▄▄█▀█ 
██         ██▀   ▀██ ██    ██    ██   ██   ▀██  ██    ██   ██   ▄█▀    █ ██▀ ▀▀    ██   ██   ██▀ ▀▀██▀  ██ ██    ██   ██   ██   ▀█▀   ███▀  ██  ██    ██    ██   ██▀ ▀▀ ▄█▀    █
██▄        ██     ██ ██    ██    ██   ██    ██  ██    ██   ██   ██▀▀▀▀▀▀ ██         ▄█████   ██    ██      ██    ██   ██   ██   ▀█▀▀▀▀▀▀█       ██    ██    ██   ██     ██ ▀▀▀▀▀
▀██▄     ▄▀██▄   ▄██ ██    ██    ██   ██   ▄██  ██    ██   ██   █▀▄    ▄ ██        ██   ██   ██    ██▄    ▄██    ██   ██   ██   ██▄    ▄█▄    ▄ ██    ██    ██   ██     ██     
  ▀▀█████▀  ▀█████▀▄████  ████  ████▄ ██████▀   ▀████▀███▄ ▀████ ▀██ ██▀████▄      ▀████▀██▄████▄   █████▀████  ████▄████▄ ▀████ ▀▄████▀█████▀  ▀████ ▀████▀███▄████▄    ▀█████▀
                                      ██                                                                                                                                        
                                    ▄████▄                                                                                                                                      
                                                             
                                                                                          
                                                                                          
 ▄▄█ █                      ▄ █▀█                     ▄▄█▀██ 
▄█▀    █     █████████     ▀█▀   ██     █████████     ▄█▀    █
██▀▀▀▀▀▀                   ▀█▀▀▀▀▀▀                   ██ ▀▀▀▀▀
█▀▄    ▄     █████████     ██▄    ▄     █████████     ██     
 ▀██ ██▀                    ▀▄████▀                    ▀█████▀
                                                                                          
                          
                                                                                                                                                                                   
```

В данном методе JBIG2 сегментирует страницу на глифы и сопоставляет похожие с образцом. После нахождения всех связанных областей (посредством сравнения пикселов), алгоритм заменяет вхождения копией одного из них. В итоге нет надобности хранить информацию о всех пикселах на странице, достаточно зафиксировать сжатую версию "эталонного глифа" (образца) и координаты для размещения его копий. Алгоритм распаковки же выходную страницу представляет в виде холста и отрисовывает на нем базовый глиф в необходимых позициях.

Основная проблема данного метода (причина, по которой `JBIG2` больше не распространен) - это случайная подмена цифр на холсте. К счастью, к нашему эксполйту она мало относится.

```text
         
               
                                    
   ▄█▄▀▄                    ▄▄▄▀▄ █▄
 ██▀                       ██     ▀
██▄▄▄█▄▀▄                 ███    ▄
▀█▀  ▀██▄     █████████    ▀▄█▄▄▄█▄ 
██    ▀██                  ██   ▀███
██▄   ▀██     █████████    ██    ▀██
▀███████                   ▀███████ 
                                    
                                    
         

```

### JBIG2: Уточняющее кодирование

Первый рассмотренный метод предполагает сжатие с потерями (поскольку хранится информация лишь об одном глифе). При уточняющем же кодировании `JBIG2` оперирует сжатием с разными степенями потерь (теперь храниться будут разностные маски):

```text
                                                                 
                                                              
                                                             
 ▄▄█▀██          ▄▀▀▄          ▄▄█ █                     ▄  ▀▀ █ 
 ▄█▀    █       █    █        ▄█▀    █     █████████             
 ██ ▀▀▀▀▀      █      █       ██▀▀▀▀▀▀                     ▀     
 ██           █        █      █▀▄    ▄     █████████      ▄▄    ▄
  ▀█████▀                      ▀██ ██▀                       █   
                                                                 
 Подставленный                Исходный                  Разностная маска
 (образцовый)                 символ
 символ                                                       




```

В данном примере применен оператор `xor`, а значит нам доступны две ступени сжатия: образцовый символ как замена исходному и сам исходный символ.

> Подумайте, как с помощью разностной маски и образцового символа восстановить исходный символ?

Для того чтобы увеличить количество ступеней сжатия (количество разностных масок), достаточно итеративно применять другие логические операторы (`or`, `and`, `xor`, `xnor`), вместо одноразового применения `xor`.

### JBIG2 в коде

Сам по себе формат `JBIG2` представляет собой серию сегментов (команд рисования), выполняющихся последовательно. Возвращаясь к парсеру CoreGraphics JBIG2, отмечу, что в его состав входят сегменты, задача которых:
- определение новой страницы
- декодирование таблицы Хаффмана
- рендеринг изображения

Определим некоторые из сущностей:
- Сегменты: `JBIG2Segment` (и подклассы: `JBIG2Bitmap`, `JBIG2SymbolDict`)
- Прямоугольный массив пикселов: `JBIG2Bitmap`
- Резервный буфер, содержащий холст рендеринга: `JBIG2Bitmap.data`
- Сгруппированные `JBIG2Bitmap`'ы: `JBIG2SymbolDict`
- Целевая страница: `JBIG2Bitmap` + отдельные глифы
- Вектор указателей на сегменты `JBIG2Segment`'ы: `GList`

### Уязвимость системы JBIG2

В момент сопоставления ссылочных сегментов происходит целочисленное переполнение:

```
Guint numSyms = 0;                                                  //  32-битное целое число
...
for (...) {
    ...
    numSyms += ((JBIG2SymbolDict *)seg)->getSize();                 // передавая сегменты нужного размера, добьемся переполнения (маленького значения)
    ...
}
...
syms = (JBIG2Bitmap **)gmallocn(numSyms, sizeof(JBIG2Bitmap *));    // созданная куча будет меньшего размера, чем требуется
kk = 0
for (...) {
    for (...) {
        syms[kk++] = symbolDict->getBitmap(k);                      // размер буфера syms слишком мал -> указатели в GList перезаписаны
    }
}
```

Изобразим данное переполнение:

```text
            ___________________________
           |                           |    |
           |   Достаточно маленький    |    |
           |          буфер            |    |
           |___________________________|    |
           |                           |    |
           |            ...            |    |   Переполнение
           |___________________________|    |
           |                           |    |
           |         Резервный         |    |
           |      буфер сегментов      |    |
           |          GList            |    |
           |___________________________|    |
           |                           |    |
           |       Битовая карта       |   \|/
           |        JBIG2Bitmap        |    -
           |   оболочка над резервным  |    
           |         буфером           |  
           |___________________________|
            
```

Очевидно, процесс не может писать в буфер бесконечно, поэтому необходимо сделать так, чтобы заражение битовой карты из-за переполнения происходило до перезаписи указателя vtable и первых 4 полей. Это достигается путём элегантной перезаписи указателей в GList (`JBIG2Segment` -> `JBIG2Bitmap`). Учитывая то, что `JBIG2Bitmap` - наследник `JBIG2Segment`, полиморфные вызовы поменяют возвращаемый тип, а значит переполнение остановится.

Далее предлагаю спуститься на уровень заражения битовой карты:

Порядок байтов в iOS соответствует little-endian, что приведет к тому, что в поля `segNum` и `h` будет записано большое число (от 0x100000 до 0xFFFFFFFF), а в `w` и `line` - маленькие.

```text
        
                   |\/\/\/\/\/\/\/\/\/\/\/\/\/\/\        |
                   |                             |       |
                   |         Резервный           |       |
                   |      буфер сегментов        |       |
                   |          GList              |       |
               __  |_____________________________|       |
              |    |                             |       |
              |    |   vtable                    |       |
              |    |                             |       |
              |    |_____________________________|       |   "Заражение"
              |    |              |              |       |
              |    | Guint segNum |  int w       |       |
              |    | Сегментов    |ширина буфера |       |
     Битовая /     |______________|______________|       |
     карта   \     |              |              |       |
              |    |  int h       |  int line    |       |
              |    |высота буфера |байт в строке |       |
              |    |______________|______________|      \|/
              |    |                             |
              |    |  Guchar* data               |
              |    |                             |
              |__  |_____________________________|
                   |                             |
                   |             ...             |
                   |                             |
                   |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                   

```
Результатом заражения стало расширение высоты холста. Высота отражает размер `резервного буфера`, а значит, мы можем изменять собственные поля:

```text
                ___________________________
               |                           |< . . . . . . . . . . . . . .
               |      Резервный буфер      |                            .
               |                           |                            .
               |. (можем менять поля)      |                            .
               |.__________________________|                            .
               |.                          |                            .
               |.          ...             |                            .
               |.                          |                            .
               |.__________________________|                            .
               |.                          |    |                       .
               |.  Достаточно маленький    |    |                       .
               |.         буфер            |    |                       .
               |.__________________________|    |                       .   Обращение к резервному буферу с большим h
               |.                          |    |                       .   для перезаписи полей
               |.          ...             |    |   Переполнение        .
               |.__________________________|    |                       .
               |.                          |    |                       .
               |.        Резервный         |    |                       .
               |.     буфер сегментов      |    |                       .
               |.         GList            |    |                       .
           __  |.__________________________|    |                       .   
          |    |.         vtable           |    |                       .
          |    |.__________________________|    |                       .
          |    |. > segNum ..|. >  w       |    |                       .
 Битовая /     |.____________|_____________|    |                       .
 карта   \     |. > h .......|. >  line    |    |                       .
          |    |_____________|_____________|   \|/                      .
          |    |  Guchar* data             |                            .
          |__  |___________________________|. . . . . . . . . . . . . . . 


```

Определив новые значения для `w`, `h` и `line`, мы можем переписать память по произвольному смещению от резервного буфера. Выполним последний шаг эксплойта: определим, откуда взять логические операции, чтобы вычислить необходимые нам адреса.

### Компьютерная архитектура в парсере изображений

Соберем то, что мы имеем на данный момент:
- Метод подстановки для перезаписи данных на холсте
- Метод уточнения для определения масок посредством выполнения логических операций
- Доступ к данным с произвольным смещением относительно резервного буфера

Всё, что нам осталось - отойти от идеи работы с глифами (буквами) и спуститься на уровень отдельных битов:

```text

            ___________________________   ___
           |                           |     |
           |                           |      \  Размер буфера исходной страницы
           |                           |      /
           |                           |     |
           |___________________________|  ___| 
           |                           |     |  
           |                           |     |
           |___________________________|     |
           |                           |     |
           |                           |     | 
           |___________________________|     |
           |                           |      \  Размер буфера страницы неограниченного размера
           |         __                |      /
           |        |a |. . . . . . . .|. . .| . . . . . 
           |                           |     |          .
           |                __         |     |          .
           |               |b |. . . . |. . .| . . . . . . . . a (and, or, xor, xnor) b
           |                           |     |
           |                           |     |
           |___________________________|  ___|

```

В итоге нам доступно выполнение логических операций между областями памяти по произвольным смещениям от резервного буфера. 

Просто переписывая память нам вряд ли удастся добиться слежки за устройством. Куда интереснее то, что нам открывается возможность создания вентиля `NAND`, обладающего функциональной полнотой. С его помощью мы можем эмулировать последовательности произвольных логических вентилей, что в конечном итоге приведет к созданию:
- регистров
- 64-битного сумматора
- компаратора

Это и определяет архитектуру простейшего компьютера.

> Вспомните (обращаясь к материалам лекции №4), как устроены логические вентили внутри

Последнее, что осталось сделать - сбежать из "песочницы". К счастью для злоумышленника, у процессов нативных приложений apple "развязаны руки", а поля объектов на момент обнаружения эксплойта не были защищены с помощью PAC (Pointer Authentication Codes). 

## Принятые меры в связи с инцидентом (побольше визуализации <u>процессов</u>)

### Обновления безопасности

13 сентября 2021 года корпорация Apple выпустила особое обновление безопасности [iOS 14.8]((https://support.apple.com/ru-ru/HT212807)), в рамках которого:

**ImageIO**:
- Воздействие. Обработка вредоносного изображения может приводить к выполнению произвольного кода.
- Описание. Проблема устранена путем улучшения проверок.

Разумеется, одних лишь слов недостаточно, давайте уточним, что на самом деле сделали разработчики:
- Ограничение количества форматов ImageIO, доступных из уязвимого кода
- Изменение способа обработки и декодирования файлов формата `.gif`

В обновлении [iOS 15.0](https://www.apple.com/ru/ios/ios-15/) было решено декодировать файлы `.gif` в безопасной изолированной среде распаковки `BlastDoor`. Данная среда изолирует iMessage от остального софта на устройстве.

### Проблема решена?

Внимательный читатель мог заметить, что проблема переполнения буфера не была решена. Что бы это могло значить? Правильно, возможность создания очередной атаки с нулевым кликом.

### Кампания "Операция Триангуляция"

Вернемся к тому, с чего я начинал повествование (обновления безопасности летом 2023 года). Как ни странно, минувшим летом лаборатория касперского обнаружила новый высокотехнологический эксплойт "Атака с нулевым кликом" и назвала действия по его обнаружению и предупреждению "Операция Триангуляция". На данный момент известно следующее:

"Заражаемое iOS-устройство получает сообщение iMessage со специальным вложением, содержащим эксплойт. Далее без какого-либо взаимодействия с пользователем, эксплойт из сообщения вызывает выполнение вредоносного кода. В процессе заражения сообщение и вложение с эксплойтом удаляются".

Что-то напоминает, не правда ли? В Apple тоже так посчитали и начали выкатывать новые обновления безопасности ([iOS 15.7.9](https://support.apple.com/ru-ru/HT213913)):

**ImageIO**:
- Воздействие. Обработка вредоносного изображения может приводить к выполнению произвольного кода. Компании Apple известно о том, что этой проблемой могли активно пользоваться.
- Описание. Проблема переполнения буфера устранена путем улучшенной обработки памяти.

Разумеется, утверждать о разрешении эксплойта пока рано. Как бы там ни было, для большей безопасности, новые механизмы "обработки памяти" скрыты.

> **Интересный факт**: огромное количество пользователей iOS-устройств столкнулись с [проблемой в работе сети](https://discussions.apple.com/thread/254791113) после обновления iOS 16. Некоторые эксперты связывают это с разрешением кампании "Операция Триангуляции", поскольку данный эксплойт для заражения посылал запросы на свой сервер управления, чтобы загрузить полноценную APT-платформу. Apple проблему решила, но комментариев не дала.

## Обобщение проблемы

### Программные факторы

Обобщим совокупность программных факторов до классов проблем:
1) Использование старого ПО
2) Использование ПО с открытым исходным кодом
3) Преждевременная оптимизация
4) Нулевой клик
5) Наивное использование полиморфизма (без проверки входных данных)

(1) - Старое ПО, несомненно, является одним из самых надежных и эффективных. Тем не менее времена меняются и весы приоритета склоняются в сторону безопасности, нежели эффективности.

(2) - Чем дольше ПО находится в открытом доступе, тем больше времени у злоумышленников на то, чтобы найти в нём изъяны

(3) - Желание сделать всё идеально для пользователя порой приводит к совершенно неожиданным последствиям

(4) - Выполнение оптимизационного кода без ведома пользователя может оказать ему "медвежью услугу"

(5) - При неправильном использовании полиморфные вызовы могут привести к ошибкам выполнения, уязвимостям безопасности и неожиданному поведению программы

### Бизнес-процессы компании
Упомянем так же недочеты в бизнес-процессах корпорации, ставшие критическими в контексте эксплойтов "Атака с нулевым кликом":
1) Раскрытие подробностей обновлений безопасности
2) Провокационные заявления

(1) - В 2022 году Apple рассказала о том, как разрешила эксплойт "Атака с нулевым кликом". В 2023 году произошла новая атака на основании того, что не было исправлено (переполнение буфера).

(2) - После описания того, как работает заражение через iMessages в 2022 году, Apple заявила, что на iOS нацелено менее 2% вредоносных программ. Новый эксплойт не заставил себя долго ждать.

## Мораль

### Атака, от которой нет защиты

### Рекомендации пользователям

### Рекомендации разработчикам

---

> **Выполнил**
>> Тучков Максим Русланович
> 
> **Группа**
>> P33121
> 
> **Преподаватель практики**
>> Горбачёв Ярослав Георгиевич
> 
> **Лектор**:
>> [Пенской Александр Владимирович](https://github.com/ryukzak)
> 
> **Список источников**:
>> 1. https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html
>> 2. https://en.wikipedia.org/wiki/JBIG2
>> 3. https://nplus1.ru/news/2021/12/18/forcedentry
>> 4. https://googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html
>> 5. https://www.xpdfreader.com/download.html
>> 6. https://support.apple.com/en-us/HT212807
>> 7. http://www.dkriesel.com/en/blog/2013/0802_xerox-workcentres_are_switching_written_numbers_when_scanning
>> 8. https://crast.net/345665/ongoing-zero-click-iphone-spyware-attack-exposed-in-imessage/
>> 9. https://www.kaspersky.ru/resource-center/definitions/zero-day-exploit
>> 10. https://www.kaspersky.ru/resource-center/definitions/what-is-zero-click-malware
>> 11. https://www.securitylab.ru/news/538630.php
>> 12. https://kod.ru/operation-triangulation-interview
>> 13. https://securelist.com/triangledb-triangulation-implant/110050/
>> 14. https://securelist.ru/trng-2023/
>> 15. https://securelist.ru/operation-triangulation/107470/
>> 16. https://habr.com/ru/news/743140/
>> 17. https://habr.com/ru/news/743268/
>> 18. https://habr.com/ru/articles/429602/
>
> Ссылка на презентацию:
>> https://docs.google.com/presentation/d/1oxQBI1k8BPWqDZkAppSXk87uJE-e102r74HFHjmC6w4/edit?usp=sharing

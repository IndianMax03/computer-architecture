# Атака с нулевым кликом или как старый софт может вставить палки в колёса современному приложению

## Предыстория

### Важные обновления системы безопасности

Несмотря на то, что я являюсь активным пользователем техники Apple, я редко обращаю внимание на подробности обновлений, выпущенных яблочной корпорацией. Как бы там ни было, недавно я начал обращать внимание на названия обновлений и обнаружил следующее: летом 2023 года компания выпустила особые обновления безопасности, что меня крайне заинтересовало. Недолго думая, я начал изучать вопрос и узнал о таком интересном явлении, как атака с нулевым кликом. Что удивительно, эксплойту этого типа порядка 2 лет, а он всё никак не даёт покоя разработчикам. О нем я и расскажу далее. 

## Описание инцидента

### NSO Group. Pegasus.

После расследования в июле 2021 года в СМИ появилась информация о том, что шпионское ПО Pegasus используется авторитарными режимами для взлома телефонов (под iOS и Android) и слежки за правозащитниками, оппозиционными журналистами и юристами. Особенность была в том, что пользователь совершенно никак не мог узнать о взломе. Для заражения устройства достаточно было знать номер телефона жертвы. Таким образом, среди пострадавших были отмечены порядка 50 тысяч телефонных номеров, зарегистрированных в следующих странах:
- Азербайджан
- Бахрейн
- Венгрия
- Индия
- Казахстан
- Марокко
- Мексика
- Объединённые Арабские Эмираты
- Руанда
- Саудовская Аравия

С тех пор корпорация Apple стала усердно выпускать обновления безопасности для защиты от одного из самых технически сложных эксплойтов.

## Описание и объяснение причин, приведших к инциденту (какие решения были приняты и почему, какие обстоятельства сложились неблагоприятным образом)

### Атака с нулевым кликом

Атака с нулевым кликом - это вид уязвимостей, позволяющих злоумышленнику выполнять вредоносные действия без взаимодействия с пользователем. Такие атаки позволяют киберпреступнику получить контроль над приложением или устройством без применения социальной инженерии.

Для точного определения конкретизируем уязвимость согласно тому, как она была обнажена в iOS. 

### iMessage

Эксплойт осуществлялся с помощью приложения iMessage (нативное приложение продукции Apple). Для установления слежки за устройством достаточно было отправить особое графическое изображение растрового формата (`.gif`) на номер телефона (или AppleID) жертвы. Неблагоприятным обстоятельством оказалось то, что разработчики захотели зациклить проигрывание гифок, а обработку скрыть от пользователя (то есть обработка `.gif` начиналась до того, как пользователь увидит уведомление о сообщении).

В общем и целом, это и есть причина, по которой данный эксплойт можно назвать "атака с нулевым кликом", ведь о его активации пользователь не знает ничего от слова совсем. Зафиксировать наличие "шпиона" на устройстве можно исключительно с помощью специалиста.

### ImageIO, CoreGraphics Framework и Xpdf toolkit

Для обработки `.gif` изображений код фреймворка ImageIO **автоматически определял формат переданного файла** (расширение файла игнорировалось). В качестве декодера выступало API фреймворка для рисования в iOS -- CoreGraphics PDF. Для парсинга же применялся доменный кодек изображений `JBIG2` (подробнее о процессе сжатия в следующей части доклада), чья реализация была взята из набора инструментов с **открытым исходным кодом** [Xpdf](https://www.xpdfreader.com/).

Использование кода парсера из легаси опенсорс набора инструментов нельзя назвать грубой ошибкой или ленью, поскольку данный код был написан во времена серьезных требований к памяти (конец 1990-х), а значит крайне хорошо сжимал изображения.

В совокупности автоопределение формата файла и уязвимый код парсера CodeGraphics `JBIG2` позволили в качестве файла передать поддельный `.gif` (содержащий в себе особый `.pdf`), который для побега из "песочницы" посредством сложных манипуляций переполнял буфер растрового изображения, эмулировал архитектуру компьютера и определял собственные сценарии.

## Описание технических деталей (побольше визуализации <u>систем</u>)

### ImageIO

Обратимся к коду библиотеки, где после расшифровки бинарных данных происходит создание объекта изображения:

```
NSData* payload = [handler decryptData:encryptedDataFromSender, ...];
if (isImagePayload) {
    UIImage* img = [UIImage imageWithData:payload];                                         //  вызов конструктора
    ...;
}
```

После которого выполняется следующий код (нужен для создания миниатюры [`thumbnail`] изображения в уведомлении):

```
CGImageRef cgImage = [image CGImage];                                                       //  стрктура растрового изображения или его маски
CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();                                 //  интерпретация цвета для изображения
CGContextRef cgContext = CGBitmapContextCreate(0, thumbnailWidth, thumbnailHeight, ...);    //  структура среды для отрисовки
CGContextDrawImage(cgContext, cgImage, ...);                                                //  отрисовка изображения
CGImageRef outImage = CGBitmapContextCreateImage(cgContext);                                //  стрктура растрового изображения или его маски
UIImage* thumbnail = [UIImage imageWithCGImage:outImage];
```

Автоопределение формата файла происходит в полиморфном вызове `testHeader` у наследников `IIO_Reader`:

```
bool IIO_Reader_LibJPEG::testHeader(IIO_Reader_LibJPEG *this, const unsigned __int8 *a2, unsigned __int64 a3, const __CFString *a4)
{
  return *a2 == 0xFF && a2[1] == 0xD8 && a2[2] == 0xFF;
}
```
Помимо IIO_Reader_LibJPEG (формат .jpeg), поддерживаются и следующие:

- IIO_Reader_**BMP**::testHeader
- IIO_Reader_**GIF**::testHeader
- IIO_Reader_**PDF**::testHeader
- IIO_Reader_**PNG**::testHeader
- ...

В совокупности описанные вызовы и определяют уязвимость нулевого клика.

### JBIG2 и методы сжатия

**JBIG2** [Joint Bi-level Image Experts Group 2] - это доменный кодек изображений (далее -- поток `JBIG2`) для бинарных изображений, работа которого основана на природе визуальной интерпретации человека (необязательно отрисовывать все пикселы, чтобы человек распознал символ).
- **доменный**: предназначен для работы с изображениями и обладает функциональностью, которая наиболее эффективна и оптимизирована для обработки этой конкретной области.
- **кодек изображений** (видеокодек): программа или алгоритм сжатия видеоданных и восстановления сжатых данных.
- **бинарное изображение**: каждый пиксел представляет один из двух цветов

Среди методов сжатия потока `JBIG2` можно отметить следующие:
- **сегментация и подстановка**: разделение изображения на различные сегменты и замена повторяющихся участков сегментами-шаблонами
- **уточняющее кодирование**: позволяет дополнительно сжимать изображения, добавляя детали к уже существующим сегментам, контролируя тем самым "потери" сжатия
- **бинаризация**: преобразует изображение в двоичный формат, разделяя его на фоновую и переднюю плоскости
- **адаптивное кодирование**: используется для кодирования двоичных данных с использованием переменной длины кодов
- **контекстное моделирование**: используется для предсказания вероятности появления определенных символов и оптимизации кодирования
- **арифметическое кодирование**: используется для эффективного представления символов с использованием дробных чисел

Первые два метода позволяют достичь экстремальных степеней сжатия. Они-то и имеют отношение к нашему эксплойту. Рассмотрим их получше.

### JBIG2: Сегментация и подстановка

```text


                                                                                                           ▄▄         ▄▄                                                        
  ▄▄█▀▀▀█▄█                                                ██                                             ███         ██   ██                   ██                              
▄██▀     ▀█                                                ██                                              ██              ██                   ██                              
██▀       ▀ ▄██▀██▄▀████████▄█████▄ ▀████████▄▀███  ▀███ ██████  ▄▄█ ██▀███▄███     ▄█▀██▄ ▀███▄███ ▄██▀██ ███████▄ ▀███ ██████  ▄ █▀█  ▄██▀████████▀███  ▀███ ▀███▄███ ▄▄▄█▀█ 
██         ██▀   ▀██ ██    ██    ██   ██   ▀██  ██    ██   ██   ▄█▀    █ ██▀ ▀▀    ██   ██   ██▀ ▀▀██▀  ██ ██    ██   ██   ██   ▀█▀   ███▀  ██  ██    ██    ██   ██▀ ▀▀ ▄█▀    █
██▄        ██     ██ ██    ██    ██   ██    ██  ██    ██   ██   ██▀▀▀▀▀▀ ██         ▄█████   ██    ██      ██    ██   ██   ██   ▀█▀▀▀▀▀▀█       ██    ██    ██   ██     ██ ▀▀▀▀▀
▀██▄     ▄▀██▄   ▄██ ██    ██    ██   ██   ▄██  ██    ██   ██   █▀▄    ▄ ██        ██   ██   ██    ██▄    ▄██    ██   ██   ██   ██▄    ▄█▄    ▄ ██    ██    ██   ██     ██     
  ▀▀█████▀  ▀█████▀▄████  ████  ████▄ ██████▀   ▀████▀███▄ ▀████ ▀██ ██▀████▄      ▀████▀██▄████▄   █████▀████  ████▄████▄ ▀████ ▀▄████▀█████▀  ▀████ ▀████▀███▄████▄    ▀█████▀
                                      ██                                                                                                                                        
                                    ▄████▄                                                                                                                                      
                                                             
                                                                                          
                                                                                          
 ▄▄█ █                      ▄ █▀█                     ▄▄█▀██ 
▄█▀    █     █████████     ▀█▀   ██     █████████     ▄█▀    █
██▀▀▀▀▀▀                   ▀█▀▀▀▀▀▀                   ██ ▀▀▀▀▀
█▀▄    ▄     █████████     ██▄    ▄     █████████     ██     
 ▀██ ██▀                    ▀▄████▀                    ▀█████▀
                                                                                          
                          
                                                                                                                                                                                   
```

В данном методе JBIG2 сегментирует страницу на глифы и сопоставляет похожие с образцом. После нахождения всех связанных областей (посредством сравнения пикселов), алгоритм заменяет вхождения копией одного из них. В итоге нет надобности хранить информацию о всех пикселах на странице, достаточно зафиксировать сжатую версию "эталонного глифа" (образца) и координаты для размещения его копий. Алгоритм распаковки же выходную страницу представляет в виде холста и отрисовывает на нем базовый глиф в необходимых позициях.

Основная проблема данного метода (причина, по которой `JBIG2` больше не распространен) - это случайная подмена цифр на холсте. К счастью, к нашему эксполйту она мало относится.

```text
         
               
                                    
   ▄█▄▀▄                    ▄▄▄▀▄ █▄
 ██▀                       ██     ▀
██▄▄▄█▄▀▄                 ███    ▄
▀█▀  ▀██▄     █████████    ▀▄█▄▄▄█▄ 
██    ▀██                  ██   ▀███
██▄   ▀██     █████████    ██    ▀██
▀███████                   ▀███████ 
                                    
                                    
         

```

### JBIG2: Уточняющее кодирование

Первый рассмотренный метод предполагает сжатие с потерями (поскольку хранится информация лишь об одном глифе). При уточняющем же кодировании `JBIG2` оперирует сжатием с разными степенями потерь (теперь храниться будут разностные маски):

```text
                                                                 
                                                              
                                                             
 ▄▄█▀██          ▄▀▀▄          ▄▄█ █                     ▄  ▀▀ █ 
 ▄█▀    █       █    █        ▄█▀    █     █████████             
 ██ ▀▀▀▀▀      █      █       ██▀▀▀▀▀▀                     ▀     
 ██           █        █      █▀▄    ▄     █████████      ▄▄    ▄
  ▀█████▀                      ▀██ ██▀                       █   
                                                                 
 Подставленный                Исходный                  Разностная маска
 (образцовый)                 символ
 символ                                                       




```

В данном примере применен оператор `xor`, а значит нам доступны две ступени сжатия: образцовый символ как замена исходному и сам исходный символ.

> Подумайте, как с помощью разностной маски и образцового символа восстановить исходный символ?

Для того чтобы увеличить количество ступеней сжатия (количество разностных масок), достаточно итеративно применять другие логические операторы (`or`, `and`, `xor`, `xnor`), вместо одноразового применения `xor`.

### JBIG2 в коде

Сам по себе формат `JBIG2` представляет собой серию сегментов (команд рисования), выполняющихся последовательно. Возвращаясь к парсеру CoreGraphics JBIG2, отмечу, что в его состав входят сегменты, задача которых:
- определение новой страницы
- декодирование таблицы
- рендеринг изображения

Определим некоторые из сущностей:
- Сегменты: `JBIG2Segment` (и подклассы: `JBIG2Bitmap`, `JBIG2SymbolDict`)
- Прямоугольный массив пикселов: `JBIG2Bitmap`
- Резервный буфер, содержащий холст рендеринга: `JBIG2Bitmap.data`
- Сгруппированные `JBIG2Bitmap`'ы: `JBIG2SymbolDict`
- Целевая страница: `JBIG2Bitmap` + отдельные глифы
- Вектор указателей на сегменты `JBIG2Segment`'ы: `GList`

### Уязвимость системы JBIG2

В момент сопоставления ссылочных сегментов происходит целочисленное переполнение:

```
Guint numSyms = 0;                                                  //  32-битное целое число
...
for (...) {
    ...
    numSyms += ((JBIG2SymbolDict *)seg)->getSize();                 // передавая сегменты нужного размера, добьемся переполнения (маленького значения)
    ...
}
...
syms = (JBIG2Bitmap **)gmallocn(numSyms, sizeof(JBIG2Bitmap *));    // созданная куча будет меньшего размера, чем требуется
kk = 0
for (...) {
    for (...) {
        syms[kk++] = symbolDict->getBitmap(k);                      // указатели в GList перезаписаны
    }
}
```

Изобразим данное переполнение:

```text
            ___________________________
           |                           |    |
           |   Достаточно маленький    |    |
           |          буфер            |    |
           |___________________________|    |
           |                           |    |
           |       Уброщик кучи        |    |
           |___________________________|    |
           |                           |    |
           |            ...            |    |   Переполнение
           |___________________________|    |
           |                           |    |
           |         Резервный         |    |
           |      буфер сегментов      |    |
           |          GList            |    |
           |___________________________|    |
           |                           |    |
           |       Битовая карта       |   \|/
           |        JBIG2Bitmap        |    -
           |   оболочка над резервным  |    
           |         буфером           |  
           |___________________________|
            
```

Заражение битовой карты из-за переполнения будет происходить не бесконечно, а лишь до перезаписи указателя vtable и первых 4 полей (определяется исходными сегментами).

Порядок байтов в iOS соответствует little-endian, что приведет к тому, что в поля `segNum` и `h` будет записано большое число (от 0x100000 до 0xFFFFFFFF), а в `w` и `line` - маленькие.

```text
        
                   |\/\/\/\/\/\/\/\/\/\/\/\/\/\/\        |
                   |                             |       |
                   |         Резервный           |       |
                   |      буфер сегментов        |       |
                   |          GList              |       |
               __  |_____________________________|       |
              |    |                             |       |
              |    |   vtable                    |       |
              |    |                             |       |
              |    |_____________________________|       |   "Заражение"
              |    |              |              |       |
              |    | Guint segNum |  int w       |       |
              |    | Сегментов    |ширина буфера |       |
     Битовая /     |______________|______________|       |
     карта   \     |              |              |       |
              |    |  int h       |  int line    |       |
              |    |высота буфера |байт в строке |       |
              |    |______________|______________|      \|/
              |    |                             |
              |    |  Guchar* data               |
              |    |                             |
              |__  |_____________________________|
                   |                             |
                   |             ...             |
                   |                             |
                   |/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
                   

```
Результатом заражения стало расширение размера холста (а значит, мы можем изменять память за пределами исходных границ резервного буфера):

```text
                ___________________________
               |                           |< . . . . . . . . . . . . . .
               |      Резервный буфер      |                            .
               |.                          |                            .
               |.__________________________|                            .
               |.                          |                            .
               |.          ...             |                            .
               |.                          |                            .
               |.__________________________|                            .
               |.                          |    |                       .
               |.  Достаточно маленький    |    |                       .
               |.         буфер            |    |                       .
               |.__________________________|    |                       .
               |.                          |    |                       .
               |.      Уброщик кучи        |    |                       .
               |.__________________________|    |                       .
               |.                          |    |                       .
               |.          ...             |    |   Переполнение        .
               |.__________________________|    |                       .
               |.                          |    |                       .
               |.        Резервный         |    |                       .
               |.     буфер сегментов      |    |                       .
               |.         GList            |    |                       .
           __  |.__________________________|    |                       .   
          |    |.         vtable           |    |                       .
          |    |.__________________________|    |                       .
          |    |. segNum     |  w          |    |                       .
 Битовая /     |.____________|_____________|    |                       .
 карта   \     |. > h        |  line       |    |                       .
          |    |_____________|_____________|   \|/                      .
          |    |  Guchar* data             |                            .
          |__  |___________________________|. . . . . . . . . . . . . . . 


```

### Методы сжатия и заражение

## Принятые меры в связи с инцидентом (побольше визуализации <u>процессов</u>)

todo

## Обобщение проблемы

todo

## Мораль и выводы, сделанные индустрией (как изменились практики компьютерных систем)

todo

---

> **Выполнил**
>> Тучков Максим Русланович
> 
> **Группа**
>> P33121
> 
> **Преподаватель практики**
>> Горбачёв Ярослав Георгиевич
> 
> **Лектор**:
>> [Пенской Александр Владимирович](https://github.com/ryukzak)
> 
> **Список источников**:
>> 1. https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html
>> 2. https://en.wikipedia.org/wiki/JBIG2
>> 3. https://nplus1.ru/news/2021/12/18/forcedentry
>> 4. https://googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html
>> 5. https://www.xpdfreader.com/download.html
>> 6. https://support.apple.com/en-us/HT212807
>> 7. http://www.dkriesel.com/en/blog/2013/0802_xerox-workcentres_are_switching_written_numbers_when_scanning
>> 8. https://crast.net/345665/ongoing-zero-click-iphone-spyware-attack-exposed-in-imessage/
>> 9. https://www.kaspersky.ru/resource-center/definitions/zero-day-exploit
>> 10. https://www.kaspersky.ru/resource-center/definitions/what-is-zero-click-malware
>> 11. https://www.securitylab.ru/news/538630.php
>> 12. https://kod.ru/operation-triangulation-interview
>> 13. https://securelist.com/triangledb-triangulation-implant/110050/
>> 14. https://securelist.ru/trng-2023/
>> 15. https://securelist.ru/operation-triangulation/107470/
>> 16. https://habr.com/ru/news/743140/
>> 17. https://habr.com/ru/news/743268/
>> 18. https://habr.com/ru/articles/429602/
>
> Ссылка на презентацию:
>> https://docs.google.com/presentation/d/1oxQBI1k8BPWqDZkAppSXk87uJE-e102r74HFHjmC6w4/edit?usp=sharing
